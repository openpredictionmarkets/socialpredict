# Refactor Plan: Break Circular Domain Dependencies - Checkpoint 2026-02-01 (Part 2)

## Goal

Break circular domain dependencies by moving orchestration to a use-case layer, isolating domain services, and removing infrastructure concerns from domain packages.

## Concrete Refactor Sequence (Exact File Moves + Interfaces)

### Step 0: Create use-case layer scaffolding

- Add folder: `backend/internal/usecases`
- Add file: `backend/internal/usecases/contracts.go`

Proposed interfaces (use cases depend on domain services, not vice-versa):

```go
package usecases

import (
    "context"
    "socialpredict/internal/domain/bets"
    "socialpredict/internal/domain/markets"
    "socialpredict/internal/domain/users"
)

type BetsService interface {
    Place(ctx context.Context, req bets.PlaceRequest) (*bets.PlacedBet, error)
    Sell(ctx context.Context, req bets.SellRequest) (*bets.SellResult, error)
}

type MarketsService interface {
    GetMarket(ctx context.Context, id int64) (*markets.Market, error)
    GetUserPositionInMarket(ctx context.Context, marketID int64, username string) (*markets.UserPosition, error)
    CreateMarket(ctx context.Context, req markets.MarketCreateRequest, creator string) (*markets.Market, error)
    ResolveMarket(ctx context.Context, marketID int64, resolution, username string) error
}

type UsersService interface {
    GetUser(ctx context.Context, username string) (*users.User, error)
    GetPublicUser(ctx context.Context, username string) (*users.PublicUser, error)
    ValidateUserExists(ctx context.Context, username string) error
    ValidateUserBalance(ctx context.Context, username string, requiredAmount, maxDebt int64) error
    ApplyTransaction(ctx context.Context, username string, amount int64, typ string) error
    DeductBalance(ctx context.Context, username string, amount int64) error
}
```

### Step 1: Move orchestration out of domain (break cycles)

- Add files:
  - `backend/internal/usecases/bets.go`
  - `backend/internal/usecases/markets.go`
- Move cross-domain logic currently in `bets`/`markets` that calls other domain services into use cases. Domain services become pure domain logic + data access.

Example use-case signatures:

```go
type BetPlacementUseCase struct {
    Bets    BetsService
    Markets MarketsService
    Users   UsersService
    MaxDebt int64
}

func (uc *BetPlacementUseCase) Place(ctx context.Context, req bets.PlaceRequest) (*bets.PlacedBet, error)
```

### Step 2: Split markets "god service" into subservices

- Keep `backend/internal/domain/markets/service.go` as a small facade and move logic to:
  - `backend/internal/domain/markets/service_core.go`
  - `backend/internal/domain/markets/service_search.go`
  - `backend/internal/domain/markets/service_leaderboard.go`
  - `backend/internal/domain/markets/service_positions.go`
  - `backend/internal/domain/markets/service_projection.go`

Add these interfaces in `backend/internal/domain/markets/interfaces.go`:

```go
type CoreService interface {
    CreateMarket(ctx context.Context, req MarketCreateRequest, creator string) (*Market, error)
    GetMarket(ctx context.Context, id int64) (*Market, error)
    ResolveMarket(ctx context.Context, marketID int64, resolution, username string) error
}

type SearchService interface {
    SearchMarkets(ctx context.Context, query string, filters SearchFilters) (*SearchResults, error)
    ListMarkets(ctx context.Context, filters ListFilters) ([]*Market, error)
    ListByStatus(ctx context.Context, status string, p Page) ([]*Market, error)
}

type LeaderboardService interface {
    GetMarketLeaderboard(ctx context.Context, marketID int64, p Page) ([]*LeaderboardRow, error)
}

type PositionsService interface {
    GetMarketPositions(ctx context.Context, marketID int64) (MarketPositions, error)
    GetUserPositionInMarket(ctx context.Context, marketID int64, username string) (*UserPosition, error)
}

type ProjectionService interface {
    ProjectProbability(ctx context.Context, req ProbabilityProjectionRequest) (*ProbabilityProjection, error)
    GetMarketDetails(ctx context.Context, marketID int64) (*MarketOverview, error)
    GetMarketBets(ctx context.Context, marketID int64) ([]*BetDisplayInfo, error)
}
```

### Step 3: Centralize wallet/balance

- Move `backend/internal/domain/users/wallet.go` → `backend/internal/domain/wallet/wallet.go`
- Move wallet errors:
  - `ErrInvalidAccountID`, `ErrInvalidUserID` from `backend/internal/domain/users/errors.go` → `backend/internal/domain/wallet/errors.go`
- New wallet service:
  - `backend/internal/domain/wallet/service.go`

```go
package wallet

type Service interface {
    Credit(ctx context.Context, username string, amount int64, typ string) error
    Debit(ctx context.Context, username string, amount int64, typ string, maxDebt int64) error
    GetBalance(ctx context.Context, username string) (int64, error)
}
```

- Update `users` domain to call wallet service internally or remove balance mutation methods from `users.Service`.

### Step 4: Move analytics GORM repository out of domain

- Move `backend/internal/domain/analytics/repository.go`
  → `backend/internal/repository/analytics/gorm_repository.go`
- Create `backend/internal/domain/analytics/repository.go` (interfaces only):

```go
type Repository interface {
    ListUsers(ctx context.Context) ([]UserSnapshot, error)
    ListMarkets(ctx context.Context) ([]MarketSnapshot, error)
    ListBetsForMarket(ctx context.Context, marketID uint) ([]BetSnapshot, error)
    ListBetsOrdered(ctx context.Context) ([]BetSnapshot, error)
    UserMarketPositions(ctx context.Context, username string) ([]positionsmath.MarketPosition, error)
}
```

- Add DTOs in `backend/internal/domain/analytics/models.go` and map in repository adapter.

### Step 5: Separate domain DTOs from persistence models

- Create domain DTOs:
  - `backend/internal/domain/bets/models.go` (BetSnapshot)
  - `backend/internal/domain/markets/models.go` (MarketSnapshot)
  - `backend/internal/domain/users/models.go` (UserSnapshot)
- Add mappers in repository layer:
  - `backend/internal/repository/bets/mappers.go`
  - `backend/internal/repository/markets/mappers.go`
  - `backend/internal/repository/users/mappers.go`

### Step 6: Make algorithms injectable

- Define algorithm interfaces:
  - `backend/internal/domain/math/algorithms.go`

```go
type ProbabilityAlgorithm interface {
    Calculate(createdAt time.Time, bets []bets.BetSnapshot) []ProbabilityPoint
}

type OutcomeAlgorithm interface {
    DivideShares(bets []bets.BetSnapshot, probs []ProbabilityPoint) (yes, no []float64)
}
```

- Use these interfaces in markets/analytics services and pass them via constructors.

### Step 7: Update handlers to use use-cases

- Handlers:
  - `backend/handlers/bets/*` call `usecases.BetPlacementUseCase`
  - `backend/handlers/markets/*` call use-case facade or directly to split services
- Remove direct cross-domain calls from handlers.

### Step 8: Test relocation

- Move integration tests out of domain:
  - `backend/internal/domain/*/*_integration_test.go` → `backend/internal/usecases/*_test.go`
- Keep domain tests pure with fakes.

---

## Branch-by-Branch Execution Plan

### Branch 1: scaffolding-usecases

- Add `backend/internal/usecases/`
- Add `backend/internal/usecases/contracts.go` (interfaces only)
- Add empty `backend/internal/usecases/bets.go` and `backend/internal/usecases/markets.go` with TODO placeholders

Exit criteria:
- Build passes with no behavior changes.

### Branch 2: move-orchestration-to-usecases

- Identify cross-domain call sites in:
  - `backend/internal/domain/bets/service.go`
  - `backend/internal/domain/markets/service.go`
- Move orchestration into `usecases/*`
- Change handlers to call use cases instead of domain services

Exit criteria:
- Domain services no longer import other domain packages for orchestration
- Handlers compile and tests pass

### Branch 3: split-markets-service

- Create new service files:
  - `service_core.go`, `service_search.go`, `service_leaderboard.go`, `service_positions.go`, `service_projection.go`
- Add interfaces in `interfaces.go`
- Update constructors and wiring in `backend/internal/app` or handler layer

Exit criteria:
- `markets/service.go` is a thin facade
- Feature tests still pass

### Branch 4: centralize-wallet

- Move file `backend/internal/domain/users/wallet.go` → `backend/internal/domain/wallet/wallet.go`
- Move wallet errors into `backend/internal/domain/wallet/errors.go`
- Create `backend/internal/domain/wallet/service.go`
- Update all callers to use wallet service instead of mutating balance in users/markets/bets

Exit criteria:
- Single entry point for balance mutations
- `users` domain no longer exposes balance mutation methods

### Branch 5: move-analytics-repo

- Move `backend/internal/domain/analytics/repository.go` → `backend/internal/repository/analytics/gorm_repository.go`
- Add domain-level repository interface + DTOs
- Update wiring to use repository adapter

Exit criteria:
- No GORM imports in `backend/internal/domain/analytics`

### Branch 6: domain-dtos-and-mappers

- Add DTOs in domain packages
- Add mappers in repository layer
- Replace `models.*` usage inside domain with DTOs

Exit criteria:
- No top-level `models` imports in domain packages (except where intentionally left)

### Branch 7: inject-algorithms

- Add `backend/internal/domain/math/algorithms.go`
- Replace direct calls to wpam/dbpm with injected interfaces
- Wire algorithm implementations in app setup

Exit criteria:
- Algorithm selection configurable via wiring/config

### Branch 8: move-integration-tests

- Move integration tests from domain to `backend/internal/usecases`
- Replace direct repo/app imports with use-case harnesses

Exit criteria:
- Domain tests are pure unit tests
- Integration tests run via use-case layer

---

## Notes and Decisions

- Use-cases orchestrate cross-domain calls; domain services become isolated and easy to unit test.
- Wallet/balance changes are routed through a single service.
- Domain packages contain only business logic + interfaces, not infrastructure or handler/presentation code.

package marketmath

import (
	"socialpredict/models"
	"sort"
)

// SellDustCalculator defines how to compute dust for a sell bet.
type SellDustCalculator interface {
	DustForSell(sellBet models.Bet, allBets []models.Bet) int64
}

// ConstantSellDustCalculator returns a fixed dust amount for every sell.
type ConstantSellDustCalculator struct {
	DustPerSell int64
}

func (c ConstantSellDustCalculator) DustForSell(sellBet models.Bet, allBets []models.Bet) int64 {
	if sellBet.Amount < 0 {
		return c.DustPerSell
	}
	return 0
}

var defaultSellDustCalculator = ConstantSellDustCalculator{DustPerSell: 1}

// GetMarketVolumeWithDust returns the market volume including accumulated dust from selling
// This ensures currency conservation by accounting for dust that remains in the market
func GetMarketVolumeWithDust(bets []models.Bet) int64 {
	baseVolume := GetMarketVolume(bets)
	dustVolume := calculateDustStack(bets)
	return baseVolume + dustVolume
}

// calculateDustStack computes total dust accumulated from all sell transactions
// Uses O(n) single-pass algorithm with chronological processing
func calculateDustStack(bets []models.Bet) int64 {
	if len(bets) == 0 {
		return 0
	}

	sortedBets := sortBetsChronologically(bets)

	return calculateDustStackWithCalculator(sortedBets, defaultSellDustCalculator)
}

func calculateDustStackWithCalculator(bets []models.Bet, calculator SellDustCalculator) int64 {
	if calculator == nil {
		return 0
	}

	var totalDust int64
	for _, bet := range bets {
		if bet.Amount >= 0 {
			continue
		}
		totalDust += calculator.DustForSell(bet, bets)
	}
	return totalDust
}

// calculateDustForSell determines dust generated by a specific sell transaction
// This is a placeholder implementation - actual dust calculation will depend on
// the selling mechanism and how shares are valued at the time of sale
func calculateDustForSell(sellBet models.Bet, allBets []models.Bet) int64 {
	return defaultSellDustCalculator.DustForSell(sellBet, allBets)
}

// GetMarketDust calculates accumulated dust for a market
// This is a utility function for dust-related calculations
func GetMarketDust(bets []models.Bet) int64 {
	return calculateDustStack(bets)
}

func sortBetsChronologically(bets []models.Bet) []models.Bet {
	sortedBets := make([]models.Bet, len(bets))
	copy(sortedBets, bets)
	sort.Slice(sortedBets, func(i, j int) bool {
		return sortedBets[i].PlacedAt.Before(sortedBets[j].PlacedAt)
	})
	return sortedBets
}

# Domain Folder Separation of Concerns - Checkpoint 2026-02-01

## Current Structure

```
/backend/internal/domain/
├── analytics/       # Analytics and financial metrics
├── bets/           # Betting domain logic
├── markets/        # Markets domain logic
├── users/          # User management and identity
└── math/           # Mathematical calculations (algorithms)
    ├── market/     # Market volume calculations
    ├── outcomes/   # Outcome distribution (DBPM algorithm)
    ├── positions/  # Position valuation calculations
    └── probabilities/ # Probability calculations (WPAM algorithm)
```

## Identified Issues

### Critical Issues

1. **Circular Domain Dependencies**
   - `bets → markets`, `bets → users`, `users → analytics`, `markets → users`
   - Creates tight coupling and makes independent testing difficult

2. **Markets "God Service" Anti-Pattern**
   - `markets/service.go` has 11+ public methods handling unrelated concerns
   - Handles: creation, resolution, search, leaderboards, bets display, positions, volume, probability projection

3. **Balance State Mutations Scattered**
   - Balance modified in 4 different places without single orchestration point:
     - `users/service.go::DeductBalance()`
     - `users/service.go::ApplyTransaction()`
     - `markets/market_creation.go::ensureCreateMarketBalance()`
     - `bets` service helpers

4. **Cross-Domain Service Calls from Within Domain Services**
   - Domain services directly call other domain services instead of being orchestrated from above

### High Priority Issues

5. **GORM Implementation in Domain**
   - `analytics/repository.go` includes GORM implementation directly
   - Couples domain package to infrastructure concerns

6. **Hard-Coded Algorithm Selection**
   - WPAM/DBPM algorithm hard-coded in:
     - `markets/market_bets.go` line 31
     - `analytics/repository.go` line 178
   - Cannot easily swap algorithms or support multiple versions

7. **Mixed Data Models**
   - Services use both `models.Bet`, `models.User`, `models.Market` (top-level)
   - AND domain-specific models like `bets.PlacedBet`, `markets.Market`, `users.User`
   - Confusion about which model is "source of truth"

8. **Configuration Injection Inconsistency**
   - `bets` receives `setup.EconomicConfig` directly
   - `analytics` receives it via `econLoader`
   - `markets` receives configuration via Config struct

### Medium Priority Issues

9. **Presentation Logic in Domain**
   - `markets/market_bets.go::buildBetDisplayInfos()` creates display-specific models
   - Presentation layer concern mixed into domain logic

10. **Private Helper Types Reduce Testability**
    - `marketGate`, `feeCalculator`, `betLedger`, `saleCalculator` in bets are private
    - Hard to test in isolation, less extensible

11. **No Single Transaction Orchestration Point**
    - Transaction types in `users/transactions.go`
    - Logic in `users/service.go::ApplyTransaction()`
    - Called from multiple packages without centralized control

12. **Wallet Logic Split Across Files**
    - `users/wallet.go` has Account and LedgerEntry value objects
    - `users/service.go` has balance deduction logic
    - `markets/service.go` has balance checking for market creation
    - `bets/service.go` has balance checking for bet placement

---

## Step-by-Step Fix Plan

### Phase 1: Critical Architectural Issues

**1. Break Circular Domain Dependencies**
- Introduce an application/use-case layer above domain services that orchestrates cross-domain operations
- Move orchestration logic (like bet placement that touches markets + users + bets) from domain services to handlers or a new `usecases/` package

**2. Split the Markets "God Service"**
- Extract into focused services:
  - `MarketService` - core CRUD
  - `MarketSearchService` - search/filtering
  - `LeaderboardService` - leaderboard calculations
  - `PositionService` - position queries
  - `ProjectionService` - probability projections

**3. Centralize Balance/Wallet State Management**
- Create a dedicated `wallet/` domain package or consolidate all balance operations into a single `WalletService` in users domain
- This service should be the **only** place balance is mutated

### Phase 2: High Priority Issues

**4. Move GORM Implementation Out of Domain**
- Move to `/backend/internal/infrastructure/persistence/` or `/backend/internal/adapters/repository/`
- Domain should only define the `Repository` interface

**5. Resolve Model Duplication**
- Top-level `models/` = persistence models (GORM)
- Domain models = business logic DTOs
- Create explicit mappers between them

**6. Make Algorithm Selection Configurable**
- Define an `Algorithm` interface
- Inject the implementation via dependency injection

**7. Standardize Configuration Injection**
- Create a consistent pattern: either pass config via constructor or use a `ConfigProvider` interface

### Phase 3: Medium Priority Improvements

**8. Extract Presentation Logic**
- Move `buildBetDisplayInfos()` and similar to handlers or create a `presentation/` package

**9. Consolidate Transaction Orchestration**
- Create a `TransactionService` that handles all transaction types with clear entry points

**10. Refactor Private Helper Types for Testability**
- Extract `marketGate`, `feeCalculator`, `betLedger` as interfaces

---

## Recommended Execution Order

| Priority | Task | Risk Level |
|----------|------|------------|
| 1 | Centralize wallet/balance operations | Medium |
| 2 | Split markets God Service | Low |
| 3 | Move GORM out of analytics domain | Low |
| 4 | Introduce use-case layer for orchestration | High |
| 5 | Standardize model separation | Medium |
| 6 | Make algorithms injectable | Low |
| 7 | Extract presentation logic | Low |

---

## Current Dependency Graph

```
handlers/
  ├── users → users domain service
  ├── markets → markets domain service
  ├── bets → bets domain service
  └── analytics → analytics domain service

Domain Layer:
  bets domain
    ├→ markets domain (GetMarket, GetUserPositionInMarket)
    ├→ users domain (GetUser, ApplyTransaction)
    └→ setup.EconomicConfig

  markets domain
    ├→ users domain (ValidateUserExists, ValidateUserBalance, DeductBalance, etc.)
    └→ wpam algorithm (for probability display)

  users domain
    ├→ analytics domain (ComputeUserFinancials)
    └→ Sanitizer (external interface)

  analytics domain
    ├→ positionsmath (for position calculations)
    ├→ setup.EconomicConfig
    └→ models (User, Market, Bet)

  math domain (pure functions)
    └→ models (Bet, Market)
```

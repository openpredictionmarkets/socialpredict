## Initial Redesign for Users service.go

### Package Targets

* identity/profile (backend/internal/domain/users/service.go:124-190, 327-435, 488-518): owns GetUser, GetPublicUser, GetPrivateProfile, CreateUser, UpdateUser, and all sanitize/update helpers. Interface exposes DTO assembly plus profile mutations; depends on a focused ProfileRepository (CRUD + sanitizer). Ledger, markets, analytics, and credentials consume only exported DTOs, not repo internals.

* ledger/credit (backend/internal/domain/users/service.go (lines 92-239)): encapsulates ValidateUserBalance, DeductBalance, ApplyTransaction, GetUserCredit. Interface coordinates with a LedgerRepository (balance reads/writes) and emits balance events for markets or analytics.

* markets/participation (backend/internal/domain/users/service.go (lines 241-300)): handles GetUserPortfolio, ListUserMarkets, mapping repo DTOs to portfolio structs. Interface depends on a MarketStatsRepository abstraction (user bets, market metadata) instead of the user repo.

* analytics/snapshots (backend/internal/domain/users/service.go:302-325, 467-485): exposes GetUserFinancials plus financialSnapshotToMap, wrapping analytics service calls and translation logic. Accepts an AnalyticsService dependency and a minimal balance reader so ledger/profile packages do not know analytics schemas.

* credentials/security (backend/internal/domain/users/service.go:53-60, 520-573): owns ChangePassword, validation, and password policy exports. Interface coordinates with an AuthRepository (credentials fetch/update) and a Sanitizer specialized for passwords.

### Interface Design

* Each package defines a narrow interface (e.g., type ProfileService interface {...}) that HTTP handlers inject individually; a thin aggregator struct wires them together for legacy consumers needing the full façade.

* Shared types (User, PublicUser, PrivateProfile, etc.) move to a users/models module to avoid circular deps. Package-specific DTOs (e.g., Portfolio) move with their package.

* Repository interfaces mirror the split to keep persistence concerns local and prevent the “god repo” antipattern.

### Migration Steps

* Extract shared models/constants from backend/internal/domain/users/service.go into a neutral module; update imports incrementally so the file still compiles.

* Create new packages (internal/domain/users/profile, .../ledger, etc.) and move corresponding logic method-by-method, replacing direct repo fields with constructor-injected dependencies per package.

* Replace the old Service with a composite struct that embeds/contains the new services and implements the legacy ServiceInterface temporarily; update interface methods to delegate.

* Gradually cut consumers over to the smaller interfaces (start with new code, then refactor existing handlers/tests). Once no callers use the monolithic interface, delete it.

* Update DI/wiring (e.g., in cmd or http setup) so repositories and sanitizers are instantiated per package. Add focused tests for each package to ensure behavior parity before removing the old service. Potential next step: consider moving sanitizer and analytics adapters behind their own interfaces to decouple policy changes even further.

### Osnat's Questions

* **What should we call the neutral module**? Codex suggests:

* A good neutral home for shared structs/constants is backend/internal/domain/users/model (or .../models). It stays in the users domain, but signals it’s just schema/value objects with no behavior, so profile, ledger, markets, analytics, and credentials packages can all import it without circular deps. If you expect helpers (e.g., converters) to live there too, stick with model; if you want “pure DTOs” only, use models.

#### Incremental Import Updates

Incremental import updates hinge on keeping the legacy service compiling while you peel logic into new packages:

* Start by creating backend/internal/domain/users/model and moving shared structs one by one; after each move, update only the references that you just moved (e.g., users.User becomes model.User). Keep aliases (type usersModel = model.User) temporarily if that eases staged changes.

* When extracting a new package (say profile), copy the existing methods into it but leave the old service delegating to the new code. Only consumers of that method switch to profile.Service imports; everyone else still pulls users.ServiceInterface.

* Avoid wide refactors in a single commit. Update imports per feature slice: first files dealing with identity types, then ledger, etc. Go’s compiler prevents unused import drift, so each step stays safe.

* If circular references appear, introduce small adapter interfaces in the old package (e.g., type BalanceReader interface { GetBalance(...) }) so new packages depend on interfaces, not the old concrete type, and you can swap dependencies without touching every import at once.
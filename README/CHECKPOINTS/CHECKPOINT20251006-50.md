Refactor scripts/backup/db_backup.sh into modular files
Context

Monolithic source file (relative to repo root):
scripts/backup/db_backup.sh

This script is invoked by the top-level ./SocialPredict backup ....

Behavior must not change (CLI flags, prompts, outputs, exit codes all preserved).

Keep the detailed backup help/usage text inside db_backup.sh.

Goals

Improve modularity and maintainability by splitting logical concerns into separate shell modules.

Make it easier to test smaller pieces (helpers vs actions).

Preserve defaults (e.g., skip owners/privileges unless PRESERVE_OWNERS=1).

No functional regressions.

New Directory Layout

Create this structure:

scripts/
  backup/
    db_backup.sh              # skinny entrypoint (keeps full help text + dispatch)
    lib/
      paths.sh                # path resolution + filesystem helpers
      env.sh                  # guards, env sourcing/validation, container checks
      pg.sh                   # Postgres helpers (psql wrappers, dump/restore builders)
      users_csv.sh            # users CSV schema + SELECT builders
      actions_fulldb.sh       # full DB actions (save/list/latest/restore/inspect)
      actions_users.sh        # users-only actions (CSV save/reset/list/latest/restore)
    tests/
      bats/                   # (optional) .bats test files later

File-by-File Responsibilities & Content Mapping

Use the functions/blocks from the current monolithic db_backup.sh and move them as follows. Keep function names the same unless noted.

scripts/backup/lib/paths.sh

Purpose: centralize path and FS helpers.

Move:

SCRIPT_DIR=..., ROOT_DIR=..., abs_path(), PARENT_OF_ROOT=..., BACKUP_ROOT=..., mkdir -p "$BACKUP_ROOT"

timestamp()

sha256_file()

Notes:

set -euo pipefail remains only in the entrypoint (db_backup.sh), not in libs.

scripts/backup/lib/env.sh

Purpose: guards and environment validation.

Move:

The SocialPredict guard:

[ -z "${CALLED_FROM_SOCIALPREDICT:-}" ] && { echo "Not called from SocialPredict"; exit 42; }


Required env var checks:

: "${APP_ENV:?...}"
: "${POSTGRES_CONTAINER_NAME:?...}"
: "${POSTGRES_USER:?...}"
: "${POSTGRES_PASSWORD:?...}"
: "${POSTGRES_DATABASE:?...}"
: "${POSTGRES_PORT:=5432}"


Container helpers: container_running(), need_container_running()

scripts/backup/lib/pg.sh

Purpose: Postgres helpers and command builders.

Move:

psql_try(), psql_smart()

pg_dump_cmd()

pg_restore_cmd() (ensure it continues to add --no-owner --no-privileges unless PRESERVE_OWNERS=1)

ensure_db_exists()

Keep behavior identical.

scripts/backup/lib/users_csv.sh

Purpose: CSV schema & SELECT builders for users-only flows.

Move:

USERS_CSV_COLUMNS=...

users_copy_sql() (current balances)

users_copy_reset_sql() (balances reset to initial)

scripts/backup/lib/actions_fulldb.sh

Purpose: Full database operations.

Move:

do_save()

do_list()

do_latest()

confirm_restore() (used by full DB restore)

do_restore_file()

do_restore_latest()

do_inspect()

scripts/backup/lib/actions_users.sh

Purpose: Users-only CSV operations with FK-safe UPSERT.

Move:

do_save_users_common()

do_save_users()

do_save_users_reset()

do_list_users()

do_latest_users()

confirm_users_restore()

do_restore_users() (keeps temp table + \COPY + ON CONFLICT(username) UPSERT flow)

do_restore_users_latest()

Keep rejection of legacy *.dump.gz users backups.

scripts/backup/db_backup.sh (skinny entrypoint)

Keep:

#!/usr/bin/env bash

set -euo pipefail

Full, detailed print_usage() help text (exactly as in the source you were given).

The main dispatch for ACTION/case (unchanged options).

Replace the top of the file to only:

set set -euo pipefail

source the libs in this order (important):

# resolve paths first to get BACKUP_ROOT
source "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/lib/paths.sh"
source "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/lib/env.sh"
source "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/lib/pg.sh"
source "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/lib/users_csv.sh"
source "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/lib/actions_fulldb.sh"
source "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/lib/actions_users.sh"


define print_usage() (verbatim from the current script) â€” stays in this file.

keep the existing ACTION=... and case statement exactly, calling the same functions.

Dispatch (unchanged)

These must continue to exist in db_backup.sh:

ACTION="${1:-"--help"}"
case "$ACTION" in
  --save) ... ;;
  --list) ... ;;
  --latest) ... ;;
  --restore) ... ;;
  --restore-latest) ... ;;
  --inspect) ... ;;
  --save-users) ... ;;
  --save-users-reset) ... ;;
  --list-users) ... ;;
  --latest-users) ... ;;
  --restore-users) ... ;;
  --restore-users-latest) ... ;;
  --help|-h) print_usage ;;
  *) echo "Unknown action: $ACTION"; echo; print_usage; exit 1 ;;
esac

Refactor Rules

No behavior changes. Outputs, prompts, exit codes preserved.

Keep the no-owner/privilege default on full restores; honor PRESERVE_OWNERS=1.

Keep CSV users restore as UPSERT by username, never TRUNCATE/DELETE users.

Maintain set -euo pipefail only in db_backup.sh, not in libs.

Every lib file should be pure functions/variables (no side effects on source).

Use robust sourcing (use $(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)).

Pass shellcheck: add minimal # shellcheck disable=... only when required.
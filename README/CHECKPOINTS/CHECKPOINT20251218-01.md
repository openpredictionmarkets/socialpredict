## Our code should adhere to the **Single Responsibility Principle**.

* **TL;DR**: A function, method, or type should do *one thing* and have *one reason to change*. If you need to change it for multiple unrelated reasons (business rules, logging, caching, DB schema, etc.), it probably violates SRP.
* **Responsibility ≠ “only one line of code”** – responsibility is about *cohesion of purpose*, not size. A function can be 50 lines and still have a single responsibility if all those lines serve the same purpose at the same level of abstraction.
* **Why it exists**: As codebases grow, “god methods” and “god structs” accumulate rules, cross-cutting concerns, and ad-hoc branching. SRP is a guardrail: whenever you feel the urge to change the same function for unrelated reasons, you split those reasons into separate units.
* **How to spot violations**:
  * The function name is vague/generic: `HandleAllTheThings`, `Process`, `DoStuff`, `ComputeAndUpdate`.
  * You see **different domains of knowledge** mixed together (HTTP, DB, business math, logging, metrics, JSON formatting all in one place).
  * You need to add multiple different kinds of tests for one function (HTTP behavior, DB behavior, calculation behavior, etc.).
* **Why it matters**:
  * **Testability**: You can unit test pure business rules without spinning up HTTP, DB, or external services.
  * **Change safety**: You can tweak one behavior (e.g., ranking algorithm) without risking unrelated behaviors (e.g., logging).
  * **Reusability**: Once separated, core logic can be reused by HTTP handlers, CLI tools, cron jobs, and background workers.
* **Relationship to Cyclomatic Complexity**: SRP often *reduces* cyclomatic complexity at the top level. Instead of one mega-function with many branches, you have a simple orchestration function plus small helpers, each with its own focused complexity and tests.

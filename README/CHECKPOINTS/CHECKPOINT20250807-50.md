üìä Project Plan: User Financial Snapshot (Stateless, Read-Only)
üîç Objective
Expand the SocialPredict backend API to return derived financial metrics for a user, using only existing models and stateless computations. The new financial snapshot will help users better understand their activity and spending, and encourage responsible trading.

We will not modify the database schema. All data will be computed dynamically.

üß± Core Principles
Stateless: No new fields or persistent tables added

Derived-only: All financials are computed from existing transactions, market positions, and user balance

Reusability: Use the existing MarketPosition struct returned by positions.CalculateAllUserMarketPositions_WPAM_DBPM

Testable: Unit tests must use modelstesting.GenerateUser, GenerateBet, and NewFakeDB

üß© Feature Overview
Add a new field in the public user API response:
"financials": { ... }

Computed fields include:

Field	Description
accountBalance	Current user balance (already exists)
maximumDebtAllowed	From EconomicConfig
amountInPlay	Sum of Value from all MarketPositions
amountBorrowed	abs(accountBalance) if balance is negative
retainedEarnings	accountBalance - amountInPlay
equity	retainedEarnings + amountInPlay - amountBorrowed
tradingProfits	sum(position.Value - position.TotalSpent)
workProfits	Sum of bonuses from transactions (e.g. type "WorkReward", "Bounty")
totalProfits	tradingProfits + workProfits

üß† Implementation Steps
1. Create ComputeUserFinancials Core Function
üìÅ handlers/math/financials/financialsnapshot.go

go
Copy
Edit
package financials

import (
	"gorm.io/gorm"
	"socialpredict/models"
	"socialpredict/setup"
	"socialpredict/handlers/math/positions"
)

func ComputeUserFinancials(db *gorm.DB, username string, accountBalance int64, econ *setup.EconomicConfig) (map[string]int64, error) {
	positions, err := positions.CalculateAllUserMarketPositions_WPAM_DBPM(db, username)
	if err != nil {
		return nil, err
	}

	var amountInPlay, tradingProfits int64
	for _, pos := range positions {
		amountInPlay += pos.Value
		tradingProfits += pos.Value - pos.TotalSpent
	}

	workProfits, err := sumWorkProfitsFromTransactions(db, username)
	if err != nil {
		return nil, err
	}

	amountBorrowed := int64(0)
	if accountBalance < 0 {
		amountBorrowed = -accountBalance
	}

	retainedEarnings := accountBalance - amountInPlay
	equity := retainedEarnings + amountInPlay - amountBorrowed
	totalProfits := tradingProfits + workProfits

	return map[string]int64{
		"accountBalance":     accountBalance,
		"maximumDebtAllowed": econ.Economics.User.MaximumDebtAllowed,
		"amountInPlay":       amountInPlay,
		"amountBorrowed":     amountBorrowed,
		"retainedEarnings":   retainedEarnings,
		"equity":             equity,
		"tradingProfits":     tradingProfits,
		"workProfits":        workProfits,
		"totalProfits":       totalProfits,
	}, nil
}
2. Helper Function to Compute Work Profits
üìÅ handlers/math/financials/workprofits.go

go
Copy
Edit
func sumWorkProfitsFromTransactions(db *gorm.DB, username string) (int64, error) {
	var sum int64
	err := db.
		Model(&models.Transaction{}).
		Where("username = ? AND type IN ?", username, []string{"WorkReward", "Bounty"}).
		Select("SUM(amount)").Scan(&sum).Error
	return sum, err
}
3. Integrate Into Public User API
üìÅ handlers/users/public.go:

At the bottom of the handler that serves user profiles:

go
Copy
Edit
econ := setup.LoadEconomicConfig()
snapshot, err := financials.ComputeUserFinancials(db, user.Username, user.AccountBalance, econ)
if err != nil {
	logging.LogErr("error generating user snapshot", err)
	http.Error(w, "Unable to generate snapshot", http.StatusInternalServerError)
	return
}

json.NewEncoder(w).Encode(map[string]interface{}{
	"user":      user.PublicUser,
	"financial": snapshot,
})
4. Unit Tests
üìÅ handlers/math/financials/financialsnapshot_test.go

Use:

modelstesting.NewFakeDB(t)

modelstesting.GenerateUser(...)

modelstesting.GenerateBet(...)

Manually insert models.Transaction with type WorkReward, Bounty

Test various cases:

All positive balances

Negative balance (borrowed)

Zero bets (clean new user)

Trading losses vs profits

üß™ Example Response
json
Copy
Edit
{
  "user": {
    "username": "jess",
    "displayName": "jess_display",
    ...
  },
  "financial": {
    "accountBalance": -9,
    "maximumDebtAllowed": 500,
    "amountInPlay": 200,
    "amountBorrowed": 9,
    "retainedEarnings": -209,
    "equity": -18,
    "tradingProfits": -50,
    "workProfits": 10,
    "totalProfits": -40
  }
}

---

Additional thoughts:

1. We should create a new endpoint, /api/users/username/financial   
2. Let's not employ any caching or optimization strategies for now, considering that CalculateAllUserMarketPosistions will need to iterate through all markets. Though this may create a lot of computation, let's not worry about it as we could always create a button to calculate it rather than a page view, if it becomes computationally difficult. 
3. We don't want to create new transaction types that do anything to the model. There is only bets. Everything should be stateless and we should avoid creating new types as much as possible, we should re-use existing types. However if using old types and needing to modify breaks additional code, then we should create a new type, only if we have to.

---

Additional Planning

## Updated Implementation Plan

### Key Finding: Transaction Model Doesn't Exist

The checkpoint references `models.Transaction` with "WorkReward" and "Bounty" types, but I found that the system only has `models.Bet`. This means we need to adapt the workProfits calculation.

### __Solution for Work Profits__

Since there are no separate transaction types and we want to remain stateless without creating new models, I propose:

- Set `workProfits` to __0__ initially
- This keeps the financial snapshot structure intact for future extensibility
- If work rewards are needed later, they could be tracked through a different mechanism

## Implementation Steps

### 1. __Create Missing Core Function__

__File:__ `backend/handlers/math/positions/positionsmath.go`

```go
func CalculateAllUserMarketPositions_WPAM_DBPM(db *gorm.DB, username string) ([]MarketPosition, error)
```

- Iterate through all active markets
- Call existing `CalculateMarketPositions_WPAM_DBPM` for each market
- Filter results for the specific username
- Aggregate all user positions across markets

### 2. __Create Financial Snapshot Package__

__File:__ `backend/handlers/math/financials/financialsnapshot.go`

```go
func ComputeUserFinancials(db *gorm.DB, username string, accountBalance int64, econ *setup.EconomicConfig) (map[string]int64, error)
```

- Use the corrected positions function name
- Calculate all financial metrics as specified in checkpoint
- Set workProfits = 0 (no separate transaction system exists)

### 3. __Create Work Profits Helper (Simplified)__

__File:__ `backend/handlers/math/financials/workprofits.go`

```go
func sumWorkProfitsFromTransactions(db *gorm.DB, username string) (int64, error) {
    return 0, nil // No separate transaction system exists
}
```

### 4. __Create New Financial Endpoint__

__File:__ `backend/handlers/users/financial.go`

```go
func GetUserFinancialHandler(w http.ResponseWriter, r *http.Request) {
    // Extract username from URL
    // Get user info
    // Compute financial snapshot
    // Return JSON response
}
```

### 5. __Add Route to Server__

__File:__ `backend/server/server.go` Add new route:

```go
router.Handle("/v0/users/{username}/financial", securityMiddleware(http.HandlerFunc(usershandlers.GetUserFinancialHandler))).Methods("GET")
```

### 6. __Create Comprehensive Tests__

__Files:__

- `backend/handlers/math/financials/financialsnapshot_test.go`
- `backend/handlers/math/positions/positionsmath_test.go` (extend)
- `backend/handlers/users/financial_test.go`

Test cases:

- User with positive balance
- User with negative balance (borrowing)
- User with no positions
- User with multiple market positions
- Trading profits vs losses

### 7. __API Response Structure__

__Endpoint:__ `GET /v0/users/{username}/financial` __Response:__

```json
{
  "financial": {
    "accountBalance": -9,
    "maximumDebtAllowed": 500,
    "amountInPlay": 200,
    "amountBorrowed": 9,
    "retainedEarnings": -209,
    "equity": -18,
    "tradingProfits": -50,
    "workProfits": 0,
    "totalProfits": -50
  }
}
```

## Project Conventions Compliance

‚úÖ __Stateless computation__ - Everything calculated from existing data\
‚úÖ __Integer accounting__ - All values as int64\
‚úÖ __Database connection pooling__ - Pass db through function chain\
‚úÖ __Public data only__ - No private financial information exposed\
‚úÖ __Reuse existing types__ - Using existing Bet model, no new transaction types\
‚úÖ __New endpoint structure__ - `/v0/users/{username}/financial`\
‚úÖ __Security middleware__ - Following existing pattern

## Assumptions & Trade-offs

1. __Work Profits = 0__: Since no separate transaction system exists, work profits will be zero. This maintains API structure for future extensibility.

2. __Performance__: The function will iterate through all markets for each user. This may be computationally expensive but follows your guidance to implement without optimization initially.

3. __Market Iteration Strategy__: I'll query all markets and check user positions, rather than trying to build complex joins.

---

Additional Thinking

1. Yes correct, there is no capability to create work profits yet, as market creators do not get compensated yet. 2. If there is a way to use a stack based computational structure to minimize time complexity, we should do that. 3. Keep in mind there are different types of profits. There are profits for markets that are active and closed, meaning, potential profits, valuation, and then profits that arre realized, meaning the market has been resolved. Does this plan take into account both potential profits (e.g. valued assets) and realized profits (resolved markets)? 

---

## Revised Implementation Plan - Optimized & Profit-Aware

### 1. __Stack-Based Optimization Strategy__

Instead of iterating through all markets (O(markets)), we'll use a user-centric approach (O(user_bets)):

```go
func CalculateAllUserMarketPositions_WPAM_DBPM(db *gorm.DB, username string) ([]MarketPosition, error) {
    // Step 1: Get all bets for this user (single query)
    var userBets []models.Bet
    db.Where("username = ?", username).Find(&userBets)
    
    // Step 2: Extract unique market IDs (stack-based)
    marketIDs := make(map[uint]bool)
    for _, bet := range userBets {
        marketIDs[bet.MarketID] = true
    }
    
    // Step 3: Only process markets where user has positions
    var allPositions []MarketPosition
    for marketID := range marketIDs {
        positions, err := CalculateMarketPositions_WPAM_DBPM(db, strconv.Itoa(int(marketID)))
        // Filter for this user and append
    }
}
```

__Time Complexity:__ O(user_bets + unique_markets) vs O(all_markets)

### 2. __Potential vs Realized Profits Architecture__

Looking at the existing `CalculateMarketPositions_WPAM_DBPM`, it already handles both scenarios through the market's `IsResolved` status. I'll extend this to create separate profit categories:

```go
type FinancialSnapshot struct {
    // Existing fields...
    TradingProfits        int64 `json:"tradingProfits"`        // TOTAL (potential + realized)
    PotentialProfits      int64 `json:"potentialProfits"`      // From active/closed markets
    RealizedProfits       int64 `json:"realizedProfits"`       // From resolved markets
    UnrealizedValue       int64 `json:"unrealizedValue"`       // Current valuation of active positions
    RealizedValue         int64 `json:"realizedValue"`         // Final payouts from resolved positions
}
```

### 3. __Enhanced Financial Calculation Logic__

```go
func ComputeUserFinancials(db *gorm.DB, username string, accountBalance int64, econ *setup.EconomicConfig) (map[string]int64, error) {
    positions, err := CalculateAllUserMarketPositions_WPAM_DBPM(db, username)
    
    var (
        totalAmountInPlay    int64
        totalTradingProfits  int64
        potentialProfits     int64  // Active/closed markets
        realizedProfits      int64  // Resolved markets
        unrealizedValue      int64  // Current valuation
        realizedValue        int64  // Final payouts
    )
    
    for _, pos := range positions {
        totalAmountInPlay += pos.Value
        profit := pos.Value - pos.TotalSpent
        totalTradingProfits += profit
        
        // Distinguish by market resolution status
        if pos.Market.IsResolved {
            realizedProfits += profit
            realizedValue += pos.Value
        } else {
            potentialProfits += profit
            unrealizedValue += pos.Value
        }
    }
    
    return map[string]int64{
        // Existing fields...
        "tradingProfits":    totalTradingProfits,
        "potentialProfits":  potentialProfits,
        "realizedProfits":   realizedProfits,
        "unrealizedValue":   unrealizedValue,
        "realizedValue":     realizedValue,
    }, nil
}
```

### 4. __Enhanced API Response Structure__

```json
{
  "financial": {
    "accountBalance": -9,
    "maximumDebtAllowed": 500,
    "amountInPlay": 200,
    "amountBorrowed": 9,
    "retainedEarnings": -209,
    "equity": -18,
    "tradingProfits": -50,
    "potentialProfits": -30,      // From active/closed markets
    "realizedProfits": -20,       // From resolved markets  
    "unrealizedValue": 150,       // Current valuation of active positions
    "realizedValue": 50,          // Final payouts from resolved positions
    "workProfits": 0,
    "totalProfits": -50
  }
}
```

### 5. __Required Data Structure Extensions__

I'll need to ensure the `MarketPosition` struct includes market resolution information:

```go
type MarketPosition struct {
    Username       string `json:"username"`
    MarketID       uint   `json:"marketId"`
    YesSharesOwned int64  `json:"yesSharesOwned"`
    NoSharesOwned  int64  `json:"noSharesOwned"`
    Value          int64  `json:"value"`
    TotalSpent     int64  `json:"totalSpent"`    // Need to add this
    IsResolved     bool   `json:"isResolved"`    // Need to add this
    ResolutionResult string `json:"resolutionResult,omitempty"` // Need to add this
}
```

### 6. __Testing Strategy for Both Profit Types__

Test cases will include:

- User with only active positions (potential profits only)
- User with only resolved positions (realized profits only)
- User with mixed positions (both types)
- User with profitable active + losing resolved positions
- User with losing active + profitable resolved positions

## Key Questions:

1. __API Fields__: Should I include both the granular breakdown (potentialProfits, realizedProfits, unrealizedValue, realizedValue) AND the aggregate tradingProfits, or would you prefer to keep the original structure and add the breakdown as separate fields?

2. __TotalSpent Calculation__: The existing `MarketPosition` struct doesn't include `TotalSpent`. I'll need to calculate this by summing the user's bet amounts for each market. Should this be added to the struct or calculated on-demand?

3. __Stack Optimization__: The user-centric approach will significantly reduce computation. Does this optimization strategy align with your architectural preferences?

---

Answers to Questions.

First off, keep in mind that the markets model has an isResolved boolean column. This can be leveraged to build further granularity.

1. Yes, we should do a granular breakdown in the API call.

2. Yes, this should be added to the struct as well. This could be further broken down by totalspentInPlay, meaning, for markets that are not resolved yet.

3. Yes, user-centric approach is good.

---

## Final Implementation Plan - Complete & Optimized

### 1. __Enhanced MarketPosition Struct__

__File:__ `backend/handlers/math/positions/positionsmath.go`

```go
type MarketPosition struct {
    Username         string `json:"username"`
    MarketID         uint   `json:"marketId"`
    YesSharesOwned   int64  `json:"yesSharesOwned"`
    NoSharesOwned    int64  `json:"noSharesOwned"`
    Value            int64  `json:"value"`
    TotalSpent       int64  `json:"totalSpent"`        // NEW: Total amount user spent in this market
    TotalSpentInPlay int64  `json:"totalSpentInPlay"`  // NEW: Amount spent in unresolved markets only
    IsResolved       bool   `json:"isResolved"`        // NEW: From market.IsResolved
    ResolutionResult string `json:"resolutionResult"`  // NEW: From market.ResolutionResult
}
```

### 2. __Optimized User-Centric Position Calculator__

__File:__ `backend/handlers/math/positions/positionsmath.go`

```go
func CalculateAllUserMarketPositions_WPAM_DBPM(db *gorm.DB, username string) ([]MarketPosition, error) {
    // Step 1: Get all user bets (single query - O(user_bets))
    var userBets []models.Bet
    if err := db.Where("username = ?", username).Find(&userBets).Error; err != nil {
        return nil, err
    }
    
    // Step 2: Build stack of unique market IDs where user has positions
    marketIDSet := make(map[uint]bool)
    userBetsByMarket := make(map[uint][]models.Bet)
    
    for _, bet := range userBets {
        marketIDSet[bet.MarketID] = true
        userBetsByMarket[bet.MarketID] = append(userBetsByMarket[bet.MarketID], bet)
    }
    
    // Step 3: Get market resolution info for all relevant markets (single query)
    marketIDs := make([]uint, 0, len(marketIDSet))
    for id := range marketIDSet {
        marketIDs = append(marketIDs, id)
    }
    
    var markets []models.Market
    if err := db.Where("id IN ?", marketIDs).Find(&markets).Error; err != nil {
        return nil, err
    }
    
    marketResolutionMap := make(map[uint]models.Market)
    for _, market := range markets {
        marketResolutionMap[uint(market.ID)] = market
    }
    
    // Step 4: Calculate positions only for markets where user has bets
    var allPositions []MarketPosition
    for marketID := range marketIDSet {
        marketIDStr := strconv.Itoa(int(marketID))
        positions, err := CalculateMarketPositions_WPAM_DBPM(db, marketIDStr)
        if err != nil {
            return nil, err
        }
        
        // Find user's position in this market
        for _, pos := range positions {
            if pos.Username == username {
                market := marketResolutionMap[marketID]
                
                // Calculate total spent by summing user's bets in this market
                totalSpent := int64(0)
                totalSpentInPlay := int64(0)
                
                for _, bet := range userBetsByMarket[marketID] {
                    totalSpent += bet.Amount
                    if !market.IsResolved {
                        totalSpentInPlay += bet.Amount
                    }
                }
                
                // Enhanced position with resolution info
                enhancedPos := MarketPosition{
                    Username:         pos.Username,
                    MarketID:         marketID,
                    YesSharesOwned:   pos.YesSharesOwned,
                    NoSharesOwned:    pos.NoSharesOwned,
                    Value:            pos.Value,
                    TotalSpent:       totalSpent,
                    TotalSpentInPlay: totalSpentInPlay,
                    IsResolved:       market.IsResolved,
                    ResolutionResult: market.ResolutionResult,
                }
                
                allPositions = append(allPositions, enhancedPos)
                break
            }
        }
    }
    
    return allPositions, nil
}
```

### 3. __Comprehensive Financial Snapshot__

__File:__ `backend/handlers/math/financials/financialsnapshot.go`

```go
func ComputeUserFinancials(db *gorm.DB, username string, accountBalance int64, econ *setup.EconomicConfig) (map[string]int64, error) {
    positions, err := CalculateAllUserMarketPositions_WPAM_DBPM(db, username)
    if err != nil {
        return nil, err
    }

    var (
        amountInPlay         int64 // Total current value across all positions
        amountInPlayActive   int64 // Value in unresolved markets only
        totalSpent           int64 // Total amount ever spent
        totalSpentInPlay     int64 // Amount spent in unresolved markets
        tradingProfits       int64 // Total profits (realized + potential)
        realizedProfits      int64 // Profits from resolved markets
        potentialProfits     int64 // Profits from unresolved markets  
        realizedValue        int64 // Final value from resolved positions
        potentialValue       int64 // Current value from unresolved positions
    )

    for _, pos := range positions {
        profit := pos.Value - pos.TotalSpent
        
        amountInPlay += pos.Value
        totalSpent += pos.TotalSpent
        tradingProfits += profit
        
        if pos.IsResolved {
            // Resolved market
            realizedProfits += profit
            realizedValue += pos.Value
        } else {
            // Unresolved market
            potentialProfits += profit
            potentialValue += pos.Value
            amountInPlayActive += pos.Value
            totalSpentInPlay += pos.TotalSpentInPlay
        }
    }

    workProfits := int64(0) // No transaction system exists yet

    amountBorrowed := int64(0)
    if accountBalance < 0 {
        amountBorrowed = -accountBalance
    }

    retainedEarnings := accountBalance - amountInPlay
    equity := retainedEarnings + amountInPlay - amountBorrowed
    totalProfits := tradingProfits + workProfits

    return map[string]int64{
        // Original required fields
        "accountBalance":     accountBalance,
        "maximumDebtAllowed": econ.Economics.User.MaximumDebtAllowed,
        "amountInPlay":       amountInPlay,
        "amountBorrowed":     amountBorrowed,
        "retainedEarnings":   retainedEarnings,
        "equity":             equity,
        "tradingProfits":     tradingProfits,
        "workProfits":        workProfits,
        "totalProfits":       totalProfits,
        
        // Enhanced granular fields
        "amountInPlayActive":  amountInPlayActive,  // Value in unresolved markets
        "totalSpent":          totalSpent,          // Total ever spent
        "totalSpentInPlay":    totalSpentInPlay,    // Spent in unresolved markets
        "realizedProfits":     realizedProfits,     // From resolved markets
        "potentialProfits":    potentialProfits,    // From unresolved markets
        "realizedValue":       realizedValue,       // Final payouts received
        "potentialValue":      potentialValue,      // Current unresolved value
    }, nil
}
```

### 4. __API Response Structure__

__Endpoint:__ `GET /v0/users/{username}/financial`

```json
{
  "financial": {
    // Original Core Fields
    "accountBalance": 250,
    "maximumDebtAllowed": 500,
    "amountInPlay": 300,
    "amountBorrowed": 0,
    "retainedEarnings": -50,
    "equity": 250,
    "tradingProfits": 50,
    "workProfits": 0,
    "totalProfits": 50,
    
    // Enhanced Granular Breakdown
    "amountInPlayActive": 200,     // Value in unresolved markets
    "totalSpent": 250,             // Total amount ever spent
    "totalSpentInPlay": 180,       // Amount spent in unresolved markets
    "realizedProfits": 20,         // Profits from resolved markets
    "potentialProfits": 30,        // Profits from unresolved markets
    "realizedValue": 100,          // Final payouts received
    "potentialValue": 200          // Current value in unresolved markets
  }
}
```

### 5. __Implementation Files Structure__

- `backend/handlers/math/positions/positionsmath.go` - Enhanced with new function
- `backend/handlers/math/financials/financialsnapshot.go` - Core financial calculations
- `backend/handlers/math/financials/workprofits.go` - Stub returning 0
- `backend/handlers/users/financial.go` - HTTP handler for new endpoint
- `backend/server/server.go` - Add new route
- Multiple test files with comprehensive coverage

### 6. __Time Complexity Achievement__

- __Before:__ O(all_markets) - iterate through every market
- __After:__ O(user_bets + unique_user_markets) - only process markets where user has positions

### 7. __Profit Categorization__

- __Realized:__ From `market.IsResolved = true`
- __Potential:__ From `market.IsResolved = false`
- __TotalSpentInPlay:__ Only spending in unresolved markets
- __AmountInPlayActive:__ Only value in unresolved markets

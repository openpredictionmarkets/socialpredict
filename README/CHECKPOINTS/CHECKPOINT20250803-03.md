Here is a detailed markdown write-up that you can copy and paste into an agent to implement the new search functionality.

Project: Implement Market Search with Status Filtering
Objective
The goal of this project is to extend the existing backend search API for markets (GET /v0/markets/search) to include a new query parameter, status. This will allow users to filter search results by market status (Active, Closed, Resolved, or All) in addition to the existing keyword search on QuestionTitle and Description.

Implementation Plan
The implementation will be focused on modifying the Go backend code that handles the search endpoint. The key steps are as follows:

Identify the relevant code file: Locate the Go file that contains the handler for the /v0/markets/search API route. This is typically within a file that defines your API routes and handlers (e.g., routes.go, handlers.go, or a similar file).

Update the API Handler Function:

The handler function will need to be updated to read the status query parameter from the incoming HTTP request.

The existing query parameter logic for the keyword search will remain, but a new conditional block will be added.

Implement Status Filtering Logic:

The logic will use the gorm.DB instance to build a dynamic database query.

A switch statement or a series of if-else conditions will be used to handle the different status values (active, closed, resolved, all).

For each status, a WHERE clause will be added to the query to filter the results based on the ResolutionDateTime and IsResolved fields from the Market model.

The time.Now() function will be used to compare against ResolutionDateTime to determine if a market is active or closed.

The all status will be the default case, where no additional WHERE clause is added for status.

Code to be Implemented
The following code provides a clear example of the logic that needs to be integrated into your existing handler.

Go

// Inside your API handler for GET /v0/markets/search
// Assume 'db' is your gorm.DB instance, and you have retrieved 'query' and 'status'
// from the request's URL query parameters.

// Retrieve the query and status parameters from the request
queryParams := r.URL.Query()
searchQuery := queryParams.Get("query")
statusParam := queryParams.Get("status")

// Start building the query with the existing keyword search
tx := db.Where("question_title LIKE ? OR description LIKE ?", "%"+searchQuery+"%", "%"+searchQuery+"%")

// Add the new conditional logic to filter by status
if statusParam != "" && statusParam != "all" {
	now := time.Now()
	switch statusParam {
	case "active":
		// A market is active if it's not resolved and its resolution date is in the future.
		tx = tx.Where("is_resolved = ? AND resolution_date_time > ?", false, now)
	case "closed":
		// A market is closed if it's not resolved and its resolution date is in the past or present.
		tx = tx.Where("is_resolved = ? AND resolution_date_time <= ?", false, now)
	case "resolved":
		// A market is resolved if the IsResolved field is true.
		tx = tx.Where("is_resolved = ?", true)
	}
}

// Prepare a slice to hold the market results
var markets []models.Market

// Execute the final query
if err := tx.Find(&markets).Error; err != nil {
	// Handle the database error, e.g., return a 500 Internal Server Error
	log.Printf("Error fetching markets: %v", err)
	http.Error(w, "Internal Server Error", http.StatusInternalServerError)
	return
}

// Return the 'markets' slice in your API response, typically as JSON.
json.NewEncoder(w).Encode(markets)

Testing Plan
After implementation, the following tests should be performed to ensure the new functionality works correctly:

Test Case 1 (Keyword Only):

Request: GET /v0/markets/search?query=bitcoin

Expected Behavior: The API should return all markets with "bitcoin" in their title or description, regardless of their status.

Test Case 2 (Keyword and Active Status):

Request: GET /v0/markets/search?query=bitcoin&status=active

Expected Behavior: The API should only return markets with "bitcoin" in their title or description that are also active (i.e., isResolved is false and ResolutionDateTime is in the future).

Test Case 3 (Keyword and Closed Status):

Request: GET /v0/markets/search?query=bitcoin&status=closed

Expected Behavior: The API should only return markets with "bitcoin" in their title or description that are also closed (i.e., isResolved is false and ResolutionDateTime is in the past).

Test Case 4 (Keyword and Resolved Status):

Request: GET /v0/markets/search?query=bitcoin&status=resolved

Expected Behavior: The API should only return markets with "bitcoin" in their title or description that have been resolved (i.e., isResolved is true).

Test Case 5 (All Status):

Request: GET /v0/markets/search?query=bitcoin&status=all

Expected Behavior: The API should behave identically to Test Case 1, returning all markets that match the keyword query.


## Proposed Redesign for /analytics/service.go

### Splitting Up the Service type on Line 44

At backend/internal/domain/analytics/service.go (line 44), fold the monolithic Service into three focused services so each handles a single axis of change:

* UserFinancialsService (repo, econLoader) – owns ComputeUserFinancials. Keep debt/equity math and position aggregation here; expose dependencies like UserMarketPositions and EconConfigLoader, nothing else.

* SystemMetricsService (repo, econLoader, calculators, assembler) – responsible only for ComputeSystemMetrics. Move ensureStrategyDefaults into its constructor so request handling never mutates collaborators; keep the calculator/assembler strategy interfaces colocated or move them into subpackages for debt, volume, fees, and DTO assembly.

* LeaderboardService (repo) – encapsulates ComputeGlobalLeaderboard plus helpers (loadLeaderboardMarketData, aggregate…, etc.). Let it depend on a dedicated LeaderboardRepo interface if the data access shape differs from other services.

* Each service gets its own file/package (e.g. userfinancials/service.go, systemmetrics/service.go, leaderboard/service.go), with narrowly scoped option structs if they need strategy injection. The former ServiceOption type becomes specific to each service (e.g. SystemMetricsOption). This way policy changes in debt/volume/fees touch only the metrics service, leaderboard ranking tweaks live with leaderboard code, and user snapshot math evolves independently.

### Splitting Up ComputeUserFinancials on Line 111

Split backend/internal/domain/analytics/service.go (line 111) into dedicated helpers so each concern changes independently:

* validateFinancialSnapshotRequest(req FinancialSnapshotRequest) error (same file or a validation.go). ComputeUserFinancials calls this first; failures return early. This keeps validation rules isolated.
fetchUserPositions(ctx, repo Repository, username string) ([]positionsmath.MarketPosition, error) or wrap in a tiny data-access struct. That allows separate testing/mocking of repository interactions.

* loadEconomicConfig(loader setup.EconConfigLoader) (*setup.EconomicConfig, error) centralizes loader presence checks and future caching/refresh logic.

* buildBaseSnapshot(req FinancialSnapshotRequest, econ *setup.EconomicConfig) *FinancialSnapshot initializes structural fields like AccountBalance and MaximumDebtAllowed.

* accumulatePositionMetrics(snapshot *FinancialSnapshot, positions []positionsmath.MarketPosition) encapsulates the loop that calculates profits, in-play amounts, and resolved vs unresolved splits.

* calculateBorrowedRetainedEquity(snapshot *FinancialSnapshot) handles the debt/equity math (AmountBorrowed, RetainedEarnings, Equity, TotalProfits) and can host future work-profit logic.

* ComputeUserFinancials then orchestrates: validate → load positions → load config → build snapshot → accumulate metrics → finalize equity. Each helper can live in its own file if needed (e.g. financial_validation.go, snapshot_math.go) so further policy changes don’t force edits to the orchestrator.

#### Pros and Cons of Putting Helpers in Separate Files

##### Pros

* **Easier mental model**: each file (e.g. financial_validation.go, snapshot_math.go, equity_math.go) advertises a single responsibility, so future maintainers know exactly where to change validation vs. math rules.

* **Tighter unit tests**: helpers can be exported (or in _test package) with targeted tests without pulling in orchestrator dependencies.

* **Reduced merge conflicts**: debt/equity tweaks no longer collide with validation edits because changes land in different files.

* **Supports independent ownership**: different engineers or squads can own separate files/modules without coordination overhead.

#### Cons

* **File sprawl**: the analytics package gains multiple tiny files, making navigation noisier and potentially flattening related helpers that might be clearer side by side.

* **Indirection cost**: finding the full flow of ComputeUserFinancials now requires jumping across several files; inline helpers make the orchestration easier to trace.

* **Dependency leakage risk**: exporting helpers across files may require widening visibility or sharing structs, which can tempt other packages to use internals that should stay private.

* **Boilerplate overhead** : each file needs package headers, imports, and sometimes duplicated doc comments; small helpers might not justify that weight compared to grouping them logically in one file or using private methods on a struct.

### Separating ComputeSystemMetrics Into Separate Layers

Move the default-wiring responsibilities out of ComputeSystemMetrics and into construction/config layers:

* Provide a separate constructor (e.g. NewSystemMetricsService(repo, loader, opts...)) that resolves every dependency up front. Inside the constructor, call the option functions and finally fill in any missing calculators/assemblers (if s.debtCalculator == nil { s.debtCalculator = DefaultDebtCalculator{} }). This makes defaults a one-time wiring step instead of mutating state at runtime.

* Let ComputeSystemMetrics assume its collaborators are fully configured. The method then just orchestrates: fetch econ config, call the calculators, pass results to the assembler. No ensureStrategyDefaults or nil checks inside the hot path.

* If the defaults depend on environment (e.g. prod vs. staging calculators), perform that logic in a higher-level factory or DI container and pass the configured calculators into the service. ComputeSystemMetrics remains unaware of wiring decisions.

This separation keeps wiring/configuration in constructors or composition roots, while the orchestration method focuses solely on executing the metrics workflow.

### Splitting Up ensureStrategyDefaults

Split ensureStrategyDefaults into responsibilities handled elsewhere:

* Move default assignment into the constructor (e.g. NewSystemMetricsService). After applying option functions, check each dependency once (if s.debtCalculator == nil { s.debtCalculator = DefaultDebtCalculator{} }). This makes the service creation layer responsible for wiring defaults, not the runtime logic.

* Remove ensureStrategyDefaults entirely from request paths like ComputeSystemMetrics. The service should assume its collaborators are set; hunting for nils during execution mixes lifecycle management with orchestration.

* If different defaults depend on feature flags or environment, create a separate builder or configuration module that fills those dependencies and returns a fully wired service. Again, that keeps responsibility for strategy selection outside the service.

By relocating the default-wiring concern to construction code, the analytics service only orchestrates metrics calculations, satisfying SRP.

### Separating Calculations and Orchestration

Pull the policy calculators (DefaultDebtCalculator, DefaultVolumeCalculator, DefaultFeeCalculator, and DefaultMetricsAssembler) into their own package or subpackages and inject them into the orchestrator instead of defining them inline:

Create files like backend/internal/domain/analytics/calculators/debt.go, …/volume.go, …/fees.go, …/assembler.go. Each file exports a struct that implements the existing DebtCalculator, VolumeCalculator, FeeCalculator, and MetricsAssembler interfaces.

Update the orchestrating service (or the dedicated SystemMetricsService if you’ve split responsibilities) so it no longer declares those structs. Instead, the constructor imports the calculators package and sets defaults there:

`import calc "socialpredict/internal/domain/analytics/calculators"

func NewSystemMetricsService(repo Repository, loader setup.EconConfigLoader, opts ...SystemMetricsOption) *SystemMetricsService {
    svc := &SystemMetricsService{
        repo:             repo,
        econLoader:       loader,
        debtCalculator:   calc.DefaultDebtCalculator{},
        volumeCalculator: calc.DefaultVolumeCalculator{},
        feeCalculator:    calc.DefaultFeeCalculator{},
        metricsAssembler: calc.DefaultMetricsAssembler{},
    }
    for _, opt := range opts {
        opt(svc)
    }
    return svc
}`

Option functions now live alongside the service, but each calculator can evolve independently in its own file/package. Tests for debt policies, fee rules, or assembler formatting target those isolated units without touching the orchestrator.

By relocating calculator implementations outside service.go, the orchestrator only coordinates dependencies and execution, while each calculator’s business logic sits in a module dedicated to that responsibility.

### Decomposing `ComputeGlobalLeaderboard`

#### Plan to decompose `ComputeGlobalLeaderboard` for SRP

* Clarify responsibilities: Identify distinct concerns inside ComputeGlobalLeaderboard: validation/early exits, data loading (users/markets/bets), domain calculations (positions, aggregates), and presentation (ranking/DTO assembly). This defines the seams.

* Define slim interfaces: Extract a LeaderboardRepo (list users, markets, bets) and a PositionsCalculator (wraps CalculateMarketPositions_WPAM_DBPM) so orchestration does not hard-depend on concrete packages.

* Split into helpers/modules:

* Validator: checks preconditions (users/markets present) and returns typed errors/empty slices.

* MarketDataLoader: builds the leaderboardMarketData slice (one responsibility: fetch + shape data).

* Aggregator: computes per-user aggregates from positions.

* EarliestBetFinder: derives first-bet timestamps from bets limited to aggregated users.

* EntryAssembler: merges aggregates + earliest bets into DTOs.

* Ranker: sorts and assigns ranks.

* Refactor orchestrator: Make ComputeGlobalLeaderboard a thin coordinator calling these collaborators in sequence. No loops or calculations inline.

* File/package layout: Place each helper in focused files (e.g., leaderboard_loader.go, leaderboard_aggregate.go, leaderboard_rank.go) or subpackage leaderboard/. Keep structs private where possible to avoid leaking internals.

* Testing strategy: Add unit tests per helper (loader with stub repo, aggregator math, earliest bet selection, ranking stability) and a light orchestration test to ensure the pipeline is wired correctly.


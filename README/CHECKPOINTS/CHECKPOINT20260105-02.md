# SRP Issues in models.go:

Mixes multiple responsibilities in one module (models.go):

* Core identity mixed with wallet/finance: User includes InitialAccountBalance/AccountBalance and market-facing fields, so the user entity changes for financial rules and account/profile changes alike.

* Auth concerns embedded in user domain: APIKey and MustChangePassword in User plus the Credentials struct mean authentication/secret handling lives in the same model as profile and balance data.

* Presentation DTOs co-located with domain: PublicUser, PrivateProfile, and UserMarket/Portfolio view models sit beside core domain entities, so display-layer shape changes force user-domain changes.

* Request payload models co-located: UserCreateRequest and UserUpdateRequest are transport-layer inputs living with domain structs, so API contract changes couple to domain model changes.

* Betting/portfolio aggregation mixed in: UserBet, MarketUserPosition, PortfolioItem, Portfolio, and UserMarket bundle market participation logic with user identity, coupling market rules to user model changes.

* Duplicate personal link representations: PersonalLink1-4 appear in User, PublicUser, UserUpdateRequest, Portfolio* aggregates, and PersonalLinks, indicating multiple concerns and repeated shape definitions rather than a focused type boundary.

## Splitting up user from wallet/account domain

Split the concerns into distinct domain packages and types, then rewire usage:

Define core identity/user: keep User to identity + profile only (id, username, display name, email, personal links/emoji, timestamps, maybe user type). Remove balance, APIKey, auth flags, market aggregates.

Define wallet/account domain: new package (e.g., domain/wallet or accounts) with Account/LedgerEntry types holding InitialBalance, Balance, currency, and transactional invariants. Expose behaviors like Credit, Debit, CanAfford there, not on User.

Define auth separately: move APIKey, MustChangePassword, and credential/hash handling into an auth package (Credentials, AuthProfile, token/api-key types). User holds only an auth identifier if needed.

Separate view/DTO shapes: keep transport/view structs near their layer (API DTOs in handler/transport, read models in query layer). PublicUser and PrivateProfile become projections composed from User + Account + Auth as needed.

Split market/betting aggregates: move UserBet, MarketUserPosition, PortfolioItem/Portfolio, UserMarket into a markets or portfolio domain. These read User by id but don’t embed balances; they can reference wallet.Account for funds.

Migration steps: introduce new packages/types, migrate constructors/services to compose User + Account + Auth, adjust repos/storage schemas accordingly, then remove balance/auth fields from User. Add compile-time/build check to ensure no wallet/auth fields remain in models.go.

Governance: add package-level lint/tests to keep wallet/auth types out of users (e.g., forbid balance fields) and update docs to note boundaries.

Proposed domain packages and core types

backend/internal/domain/users

Purpose: identity + profile only.
Type:
package users

type User struct {
    ID           int64
    Username     string
    DisplayName  string
    PersonalLink string // single link as requested
    PersonalEmoji string
}
Add invariants/constructors here (username/display name rules), nothing about auth, balances, or markets.
backend/internal/domain/wallet (or accounts)

Purpose: balances and money movement.
Types: Account{UserID int64, Balance int64, Currency string}, LedgerEntry{AccountID, Amount, Kind, CreatedAt}, behaviors Credit/Debit/CanAfford.
backend/internal/domain/auth

Purpose: credentials and access control.
Types: Credentials{UserID, PasswordHash, MustChangePassword}, APIKey{UserID, Key, CreatedAt, ExpiresAt}, helper methods for rotation/validation.
backend/internal/domain/portfolio (or markets/portfolio)

Purpose: user’s market participation/read models.
Types: Position{UserID, MarketID, YesShares, NoShares, LastBetAt}, Portfolio{UserID, Items []Position}, optional projections for user-market summaries.

## single link or multiple links?

Single link: simpler model and validation; fewer UI/API fields to maintain; lower risk of leakage/misordering. But it constrains users to one destination, forces overloading (one “link hub”), and you’ll need a breaking change later if multiple links become required.

Multiple links (fixed slots): more flexibility for users; clear separation of distinct destinations (e.g., website vs. socials). But extra fields add noise, validation, and mapping; fixed slots can create empty/unused fields and still require breaking changes if you need more/less.

Multiple links (list/array): most flexible and future-proof; easy to add/remove/reorder without schema breaks. But requires stronger validation (max count, allowed domains), stable ordering/labeling, and careful API/UI design to avoid leaking untrusted data.

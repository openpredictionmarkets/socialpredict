# SRP Issues in models.go:

Mixes multiple responsibilities in one module (models.go):

* Core identity mixed with wallet/finance: User includes InitialAccountBalance/AccountBalance and market-facing fields, so the user entity changes for financial rules and account/profile changes alike.

* Auth concerns embedded in user domain: APIKey and MustChangePassword in User plus the Credentials struct mean authentication/secret handling lives in the same model as profile and balance data.

* Presentation DTOs co-located with domain: PublicUser, PrivateProfile, and UserMarket/Portfolio view models sit beside core domain entities, so display-layer shape changes force user-domain changes.

* Request payload models co-located: UserCreateRequest and UserUpdateRequest are transport-layer inputs living with domain structs, so API contract changes couple to domain model changes.

* Betting/portfolio aggregation mixed in: UserBet, MarketUserPosition, PortfolioItem, Portfolio, and UserMarket bundle market participation logic with user identity, coupling market rules to user model changes.

* Duplicate personal link representations: PersonalLink1-4 appear in User, PublicUser, UserUpdateRequest, Portfolio* aggregates, and PersonalLinks, indicating multiple concerns and repeated shape definitions rather than a focused type boundary.

## Splitting up user from wallet/account domain

Split the concerns into distinct domain packages and types, then rewire usage:

Define core identity/user: keep User to identity + profile only (id, username, display name, email, personal links/emoji, timestamps, maybe user type). Remove balance, APIKey, auth flags, market aggregates.

Define wallet/account domain: new package (e.g., domain/wallet or accounts) with Account/LedgerEntry types holding InitialBalance, Balance, currency, and transactional invariants. Expose behaviors like Credit, Debit, CanAfford there, not on User.

Define auth separately: move APIKey, MustChangePassword, and credential/hash handling into an auth package (Credentials, AuthProfile, token/api-key types). User holds only an auth identifier if needed.

Separate view/DTO shapes: keep transport/view structs near their layer (API DTOs in handler/transport, read models in query layer). PublicUser and PrivateProfile become projections composed from User + Account + Auth as needed.

Split market/betting aggregates: move UserBet, MarketUserPosition, PortfolioItem/Portfolio, UserMarket into a markets or portfolio domain. These read User by id but donâ€™t embed balances; they can reference wallet.Account for funds.

Migration steps: introduce new packages/types, migrate constructors/services to compose User + Account + Auth, adjust repos/storage schemas accordingly, then remove balance/auth fields from User. Add compile-time/build check to ensure no wallet/auth fields remain in models.go.

Governance: add package-level lint/tests to keep wallet/auth types out of users (e.g., forbid balance fields) and update docs to note boundaries.

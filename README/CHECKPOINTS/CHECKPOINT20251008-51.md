Goal

Add a customizable home page served at / whose content:

is seeded from a Markdown file into the DB on first run,

renders as HTML (Markdown → HTML, sanitized),

is editable by admins from /admin (supporting both Markdown and rich text (HTML) saves),

is exposed via server endpoints (public read, admin write), with core logic isolated from HTTP.

Architecture & Decisions

Model: HomepageContent holds the current home content (and optional history/audit).

Rendering: Markdown stored → rendered to HTML server-side using a renderer service (e.g., goldmark), then sanitized (e.g., bluemonday UGCPolicy).

Rich text option: Admins may save HTML directly. We still sanitize to keep the page safe.

Seeding: A repo file (e.g., frontend/src/content/home.md) is used as the initial seed. A seeders function inserts it if the DB has no record.

HTTP split: Core logic lives in handlers/cms/homepage service + repository; HTTP handlers are thin adapters.

Testing: Use modelstesting.NewFakeDB for GORM, plus your helpers for users. Unit test core service (Markdown→HTML, sanitization), repo, and basic handlers.

Data Model

File: backend/models/homepage.go

package models

import "time"

type HomepageContent struct {
	ID        uint      `gorm:"primaryKey"`
	Slug      string    `gorm:"uniqueIndex;size:64"` // always "home"
	Title     string    `gorm:"size:255"`
	Format    string    `gorm:"size:16"` // "markdown" or "html"
	Markdown  string    `gorm:"type:text"`
	HTML      string    `gorm:"type:text"`
	Version   uint      `gorm:"default:1"` // optimistic locking
	UpdatedBy string    `gorm:"size:64"`
	CreatedAt time.Time
	UpdatedAt time.Time
}


If you want edit history, add a HomepageContentVersion table and write to it on each update.

Migration

File: backend/migration/migrations/20251008_add_homepage_content.go

package migrations

import (
	"gorm.io/gorm"
	"socialpredict/models"
)

func init() {
	register(func(db *gorm.DB) error {
		return db.AutoMigrate(&models.HomepageContent{})
	})
}


(If you use your existing migration.MigrateDB(db) registry style, hook it in exactly as your other migrations.)

Seeder

File: backend/seeders/homepage.go

package seeders

import (
	"os"
	"path/filepath"

	"gorm.io/gorm"
	"socialpredict/models"
)

func SeedHomepage(db *gorm.DB, repoRoot string) error {
	var count int64
	if err := db.Model(&models.HomepageContent{}).
		Where("slug = ?", "home").Count(&count).Error; err != nil {
		return err
	}
	if count > 0 {
		return nil
	}

	// default seed path lives next to frontend
	mdPath := filepath.Join(repoRoot, "frontend", "src", "content", "home.md")
	data, err := os.ReadFile(mdPath)
	if err != nil {
		// If file missing, seed with a trivial default
		data = []byte("# Welcome to BrierFoxForecast\n\nThis is the seeded home page.")
	}

	item := models.HomepageContent{
		Slug:     "home",
		Title:    "Home",
		Format:   "markdown",
		Markdown: string(data),
		HTML:     "",      // rendered later by service
		Version:  1,
	}

	return db.Create(&item).Error
}


Call SeedHomepage(db, repoRoot) from your existing seed flow (where you seed markets/users), preferably after migrations.

Core Package (Service + Repository)

Dir: backend/handlers/cms/homepage/

Repository

File: repo.go

package homepage

import (
	"gorm.io/gorm"
	"socialpredict/models"
)

type Repository interface {
	GetBySlug(slug string) (*models.HomepageContent, error)
	Save(item *models.HomepageContent) error
}

type GormRepository struct{ db *gorm.DB }

func NewGormRepository(db *gorm.DB) *GormRepository { return &GormRepository{db: db} }

func (r *GormRepository) GetBySlug(slug string) (*models.HomepageContent, error) {
	var item models.HomepageContent
	if err := r.db.Where("slug = ?", slug).First(&item).Error; err != nil {
		return nil, err
	}
	return &item, nil
}

func (r *GormRepository) Save(item *models.HomepageContent) error {
	return r.db.Save(item).Error
}

Service

File: service.go

package homepage

import (
	"errors"

	"socialpredict/models"

	"github.com/microcosm-cc/bluemonday"
	"github.com/yuin/goldmark"
)

type Renderer interface {
	MarkdownToHTML(md string) (string, error)
	SanitizeHTML(html string) string
}

type DefaultRenderer struct {
	md goldmark.Markdown
	pm *bluemonday.Policy
}

func NewDefaultRenderer() *DefaultRenderer {
	return &DefaultRenderer{
		md: goldmark.New(),
		pm: bluemonday.UGCPolicy(),
	}
}

func (r *DefaultRenderer) MarkdownToHTML(md string) (string, error) {
	var buf []byte
	var w = new(bytes.Buffer)
	if err := r.md.Convert([]byte(md), w); err != nil {
		return "", err
	}
	return w.String(), nil
}

func (r *DefaultRenderer) SanitizeHTML(html string) string {
	return r.pm.Sanitize(html)
}

// Use higher-order injection for renderer & repository for testability.
type Service struct {
	repo     Repository
	renderer Renderer
}

func NewService(repo Repository, renderer Renderer) *Service {
	return &Service{repo: repo, renderer: renderer}
}

type UpdateInput struct {
	Title     string
	Format    string // "markdown" or "html"
	Markdown  string
	HTML      string
	UpdatedBy string
	Version   uint
}

func (s *Service) GetHome() (*models.HomepageContent, error) {
	return s.repo.GetBySlug("home")
}

func (s *Service) UpdateHome(in UpdateInput) (*models.HomepageContent, error) {
	item, err := s.repo.GetBySlug("home")
	if err != nil {
		return nil, err
	}
	// optimistic lock check (optional; keep consistent with your style)
	if in.Version != 0 && in.Version != item.Version {
		return nil, errors.New("version mismatch")
	}

	item.Title = in.Title
	item.Format = in.Format
	item.UpdatedBy = in.UpdatedBy
	item.Version = item.Version + 1

	switch in.Format {
	case "markdown":
		item.Markdown = in.Markdown
		rendered, err := s.renderer.MarkdownToHTML(in.Markdown)
		if err != nil {
			return nil, err
		}
		item.HTML = s.renderer.SanitizeHTML(rendered)
	case "html":
		item.HTML = s.renderer.SanitizeHTML(in.HTML)
		item.Markdown = "" // optional: clear or keep last md
	default:
		return nil, errors.New("unsupported format")
	}

	if err := s.repo.Save(item); err != nil {
		return nil, err
	}
	return item, nil
}


Note: You’ll need bytes import for service.go.

HTTP Endpoints

Dir: backend/handlers/cms/homepage/http/

File: routes.go

package http

import (
	"encoding/json"
	"net/http"

	"socialpredict/handlers/cms/homepage"
	"socialpredict/middleware"
)

type Handler struct {
	svc *homepage.Service
}

func NewHandler(svc *homepage.Service) *Handler { return &Handler{svc: svc} }

func (h *Handler) PublicGet(w http.ResponseWriter, r *http.Request) {
	item, err := h.svc.GetHome()
	if err != nil {
		http.Error(w, "not found", http.StatusNotFound)
		return
	}
	_ = json.NewEncoder(w).Encode(map[string]any{
		"title":     item.Title,
		"format":    item.Format,
		"html":      item.HTML,
		"markdown":  item.Markdown, // optional to expose
		"version":   item.Version,
		"updatedAt": item.UpdatedAt,
	})
}

type updateReq struct {
	Title    string `json:"title"`
	Format   string `json:"format"`   // "markdown" | "html"
	Markdown string `json:"markdown"` // when format=markdown
	HTML     string `json:"html"`     // when format=html
	Version  uint   `json:"version"`
}

func (h *Handler) AdminUpdate(w http.ResponseWriter, r *http.Request) {
	// Ensure you have admin-only middleware protecting this route:
	// e.g., middleware.RequireAdmin(h.AdminUpdate)
	var in updateReq
	if err := json.NewDecoder(r.Body).Decode(&in); err != nil {
		http.Error(w, "bad request", http.StatusBadRequest)
		return
	}
	user := middleware.UsernameFromContext(r.Context()) // or however you store admin identity
	item, err := h.svc.UpdateHome(homepage.UpdateInput{
		Title:     in.Title,
		Format:    in.Format,
		Markdown:  in.Markdown,
		HTML:      in.HTML,
		Version:   in.Version,
		UpdatedBy: user,
	})
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	_ = json.NewEncoder(w).Encode(map[string]any{
		"title":   item.Title,
		"format":  item.Format,
		"html":    item.HTML,
		"version": item.Version,
	})
}

Route Mounting

Add to your router setup (keeping your versioned API pattern):

GET /v0/content/home → public

PUT /v0/admin/content/home → admin-only

If you use a central routes.go, wire:

repo := homepage.NewGormRepository(db)
renderer := homepage.NewDefaultRenderer()
svc := homepage.NewService(repo, renderer)
h := cmshomehttp.NewHandler(svc)

router.HandleFunc("/v0/content/home", h.PublicGet).Methods("GET")
router.HandleFunc("/v0/admin/content/home", middleware.RequireAdmin(h.AdminUpdate)).Methods("PUT")


(Adjust for your mux/chi/gin and middleware)

Frontend Changes

Seed file:
frontend/src/content/home.md (your pasted copy of current JSX content, converted to Markdown).
The copy you provided can be rewritten as Markdown; keep the CTA link, code of conduct as bullet list, etc.

Home component (render from API):
frontend/src/pages/Home.tsx

import React, { useEffect, useState } from 'react';
import BrierFoxLogoPNG from '../../assets/png/BrierFoxLogo.png';

type HomeContent = {
  title: string;
  html: string;
  version: number;
};

export default function Home() {
  const [content, setContent] = useState<HomeContent | null>(null);

  useEffect(() => {
    fetch('/v0/content/home')
      .then(r => r.json())
      .then(d => setContent({ title: d.title, html: d.html, version: d.version }))
      .catch(() => setContent(null));
  }, []);

  return (
    <div className="min-h-[calc(100vh-6rem)] bg-primary-background text-custom-gray-verylight flex flex-col justify-center py-8 px-4 sm:px-6 lg:px-8">
      <div className="max-w-4xl mx-auto w-full">
        <div className="flex flex-col sm:flex-row items-center mb-8">
          <img src={BrierFoxLogoPNG} alt="BrierFoxForecast Logo" className="w-24 h-24 sm:w-32 sm:h-32 mb-4 sm:mb-0 sm:mr-6" />
          <div className="flex flex-col justify-center h-full text-center sm:text-left">
            <h1 className="text-3xl sm:text-4xl font-bold text-custom-gray-light mb-2">BrierFoxForecast (BFF)</h1>
            <p className="text-lg text-custom-gray-light">An alpha project powered by SocialPredict's open-source prediction market platform.</p>
          </div>
        </div>

        {/* Server-rendered content */}
        <div className="prose prose-invert max-w-none" dangerouslySetInnerHTML={{ __html: content?.html ?? '' }} />

        {!content && (
          <div className="text-sm text-gray-400 mt-6">Failed to load dynamic home content.</div>
        )}
      </div>
    </div>
  );
}


Admin editor (phase 1: Markdown textarea; phase 2: rich text):

frontend/src/pages/admin/HomeEditor.tsx — use a Markdown textarea (or Quill/Tiptap later).

Calls PUT /v0/admin/content/home with either {format:"markdown", markdown} or {format:"html", html}.

Display version and include it on save for optimistic locking.

Security & Validation

Sanitize all HTML before saving, both Markdown-rendered and direct rich text (bluemonday.UGCPolicy).

Require Admin for PUT /v0/admin/content/home. Reuse your existing admin middleware.

Rate limit admin write route (optional) using your existing approach.

Audit: If desired, add HomepageContentVersion + ContentEditLog to track who changed what and revert.

Tests

Dir: backend/handlers/cms/homepage/

Service tests (service_test.go)

Markdown → rendered HTML contains expected tags.

Sanitization strips <script> etc.

Update flow increments version and respects optimistic locking.

Repo tests (repo_test.go)

Use modelstesting.NewFakeDB(t) then migrate, save + read.

HTTP handler tests (http/handler_test.go)

GET returns 200 and payload.

PUT with admin context updates content; with bad version → 400.

Seeder test (seeders/homepage_test.go)

With empty DB, seeds entry; with existing, no duplicate.

Example unit test sketch:

func TestMarkdownRenderAndSanitize(t *testing.T) {
  db := modelstesting.NewFakeDB(t)
  _ = db.AutoMigrate(&models.HomepageContent{})

  repo := homepage.NewGormRepository(db)
  renderer := homepage.NewDefaultRenderer()
  svc := homepage.NewService(repo, renderer)

  // Seed initial
  _, _ = db.DB() // ensure connection
  _, err := svc.UpdateHome(homepage.UpdateInput{
    Title:    "Home",
    Format:   "markdown",
    Markdown: "Hello **world** <script>alert('x')</script>",
    Version:  0,
    UpdatedBy:"tester",
  })
  if err == nil {
    t.Log("created or updated")
  }

  got, _ := svc.GetHome()
  if strings.Contains(got.HTML, "<script>") {
    t.Fatalf("HTML not sanitized")
  }
  if !strings.Contains(got.HTML, "<strong>world</strong>") {
    t.Fatalf("markdown not rendered")
  }
}


(Adapt imports and helper usage to your conventions.)

Rollout Plan

Create model + migration.

Add seeder, place frontend/src/content/home.md content (converted from your JSX).

Implement repo + service + HTTP handlers; wire routes.

Frontend Home.tsx fetch/render flow; Admin editor page (Markdown first).

Tests pass (service/repo/handlers/seeders).

Deploy: run migrations + seeders; verify /v0/content/home returns HTML.

Toggle admin save & confirm content persists and renders.

Optional phase 2: swap Admin editor to rich editor (Quill/Tiptap); keep sanitization.

API Contract

GET /v0/content/home
Response 200:

{
  "title": "Home",
  "format": "markdown",
  "html": "<h1>...</h1>",
  "markdown": "# ...",
  "version": 3,
  "updatedAt": "2025-10-08T19:12:00Z"
}


PUT /v0/admin/content/home (admin only)
Request:

{
  "title": "Home",
  "format": "markdown",
  "markdown": "# My new content",
  "version": 3
}


—or—

{
  "title": "Home",
  "format": "html",
  "html": "<h1>My new content</h1>",
  "version": 3
}


Response 200:

{
  "title": "Home",
  "format": "markdown",
  "html": "<h1>My new content</h1>",
  "version": 4
}

Cline / Claude Code Task List (Copy/Paste)

Create model & migration

Add backend/models/homepage.go (as above).

Add migration backend/migration/migrations/20251008_add_homepage_content.go.

Run migrations locally to confirm table creation.

Add seeder & seed file

Create backend/seeders/homepage.go and call it in your seeding flow.

Add frontend/src/content/home.md with the updated Markdown version of the current JSX content.

Create homepage core package

backend/handlers/cms/homepage/repo.go

backend/handlers/cms/homepage/service.go

Ensure goldmark and bluemonday are added to go.mod.

HTTP handlers & routes

backend/handlers/cms/homepage/http/routes.go

Wire routes:

GET /v0/content/home (public)

PUT /v0/admin/content/home (admin middleware)

Frontend integration

Update frontend/src/pages/Home.tsx to fetch and render html.

Create frontend/src/pages/admin/HomeEditor.tsx with a Markdown textarea that calls the admin PUT endpoint (include version).

Tests

backend/handlers/cms/homepage/service_test.go (render & sanitize, optimistic locking).

backend/handlers/cms/homepage/repo_test.go (CRUD via modelstesting.NewFakeDB).

backend/handlers/cms/homepage/http/handler_test.go (GET/PUT happy/edge paths).

backend/seeders/homepage_test.go.

Security & polish

Confirm admin middleware protects PUT route.

Confirm sanitizer strips scripts/unsafe attributes.

Optional: add HomepageContentVersion + ContentEditLog.

Deploy

Ship migration + seeder.

Verify /v0/content/home.

Edit via /admin UI, confirm update + sanitization.

Notes on Rich Text (Phase 2)

Frontend: Integrate a WYSIWYG (Tiptap/Quill). Save HTML with format:"html".

Backend: Keep sanitization. Optionally restrict allowed tags (images, iframes, etc.) via bluemonday.Policy.

Preview: Provide toggle preview in admin editor to display server-sanitized output (compare pre/post to show what was stripped).
## SRP Gaps

* backend/internal/domain/analytics/service.go:44 – The Service type simultaneously delivers three unrelated feature sets: per-user financial snapshots (ComputeUserFinancials), global system metrics (ComputeSystemMetrics), and the profitability leaderboard (ComputeGlobalLeaderboard). Each use case answers to different stakeholders and policies, so changing any of them forces edits to the same struct, violating SRP.

* backend/internal/domain/analytics/service.go:111 – ComputeUserFinancials performs input validation, data access, config loading, metrics math, equity/debt calculations, and even carries a TODO about work profits. That blending of concerns means a change to validation rules, persistence strategy, or financial formulas all touch this one method.

* backend/internal/domain/analytics/service.go:164 – ComputeSystemMetrics is responsible for dependency defaulting (ensureStrategyDefaults), orchestrating calculator invocations, and DTO assembly. Those are separate axes of change: wiring defaults belongs in construction/config layers, while orchestration should not also mutate internal dependency state.

* backend/internal/domain/analytics/service.go:359 – ensureStrategyDefaults mutates collaborators lazily during runtime instead of at creation. This blends lifecycle management with request handling; any adjustment to defaulting policy requires editing the service that should otherwise just coordinate analytics calculations.

* backend/internal/domain/analytics/service.go:205 – The concrete calculators (DefaultDebtCalculator, DefaultVolumeCalculator, DefaultFeeCalculator, DefaultMetricsAssembler) encapsulate distinct business policies (debt allowances, volume accounting, fee rules, DTO formatting) but live inside the same module as the orchestrating service. Each policy change (e.g., fee math vs. debt math) now forces changes to this file, so the module itself violates SRP.

* backend/internal/domain/analytics/service.go:386 – ComputeGlobalLeaderboard owns another full pipeline: user/market existence checks, data loading, aggregation, earliest bet discovery, entry assembly, and ranking. Multiple helper functions belong to this use case, but they still sit in the same service and mix persistence (repo calls in loadLeaderboardMarketData) with computation. Changes to ranking rules, data-shaping, or persistence concerns will all require edits here, signalling a departure from SRP.
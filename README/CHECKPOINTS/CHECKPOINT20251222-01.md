## Implementation of splitting up ServiceInterface in /markets/service.go

To implement the split in service.go, add focused interfaces, keep Service implementing all of them, and update call sites to depend on the narrow slice they need.

Suggested five interfaces

`// Commands
type MarketAuthoring interface {
    CreateMarket(ctx context.Context, req MarketCreateRequest, creatorUsername string) (*Market, error)
    SetCustomLabels(ctx context.Context, marketID int64, yesLabel, noLabel string) error
    ResolveMarket(ctx context.Context, marketID int64, resolution string, username string) error
}

// General reads
type MarketQueries interface {
    GetMarket(ctx context.Context, id int64) (*Market, error)
    ListMarkets(ctx context.Context, filters ListFilters) ([]*Market, error)
    ListByStatus(ctx context.Context, status string, p Page) ([]*Market, error)
    SearchMarkets(ctx context.Context, query string, filters SearchFilters) (*SearchResults, error)
    GetPublicMarket(ctx context.Context, marketID int64) (*PublicMarket, error)
}

// Participant-facing views
type MarketParticipantViews interface {
    GetMarketDetails(ctx context.Context, marketID int64) (*MarketOverview, error)
    GetMarketBets(ctx context.Context, marketID int64) ([]*BetDisplayInfo, error)
    GetMarketPositions(ctx context.Context, marketID int64) (MarketPositions, error)
    GetUserPositionInMarket(ctx context.Context, marketID int64, username string) (*UserPosition, error)
}

// Analytics/calculations
type MarketAnalytics interface {
    CalculateMarketVolume(ctx context.Context, marketID int64) (int64, error)
    ProjectProbability(ctx context.Context, req ProbabilityProjectionRequest) (*ProbabilityProjection, error)
}

// Leaderboard (presentation-style aggregation)
type MarketLeaderboard interface {
    GetMarketLeaderboard(ctx context.Context, marketID int64, p Page) ([]*LeaderboardRow, error)
}`

Steps to apply:

In service.go, add these interfaces, remove/mark deprecated the old ServiceInterface.
Leave Service unchanged functionally; optionally assert implementation:
`var (
    _ MarketAuthoring        = (*Service)(nil)
    _ MarketQueries          = (*Service)(nil)
    _ MarketParticipantViews = (*Service)(nil)
    _ MarketAnalytics        = (*Service)(nil)
    _ MarketLeaderboard      = (*Service)(nil)
)`
Update constructors/types that accept `ServiceInterface` to instead take the specific interface they need (e.g., handlers that only read markets depend on MarketQueries; analytics jobs use MarketAnalytics; UI leaderboard endpoints use MarketLeaderboard).
Adjust tests/mocks: replace mocks of `ServiceInterface` with mocks for the relevant split interfaces; for shared mocks you can compose interfaces in test helpers.
Delete or keep `ServiceInterface` only as a legacy alias:
`type ServiceInterface interface {
    MarketAuthoring
    MarketQueries
    MarketParticipantViews
    MarketAnalytics
    MarketLeaderboard
}`
Then transition call sites off it iteratively.
This separation reduces coupling: readers don’t pull in commands, and analytics consumers don’t depend on presentation DTOs.

## Unbundling CreateMarket

Break the `CreateMarket` workflow into single-purpose steps with helpers (or private methods) instead of one monolith:

* Validate request shape: keep `validateCreateRequest` focused on title/description/labels, not business rules.
* Business rules go into dedicated helpers.
* Timing rules (e.g., resolution in the future, min/max duration) → validateResolutionWindow or ValidateMarketResolutionTime, called separately.
* User existence and eligibility → validateCreator that delegates to userService.ValidateUserExists and any role/permission checks.
* Funding rules (balance/debt thresholds, create-market fee) → ensureCreateMarketBalance or validateFunding, isolated so pricing/debt policy changes don’t touch other checks.
* Any domain caps (e.g., per-user market limits, category restrictions) → their own helper (e.g., validateAuthoringLimits).
* Normalize labels: a pure helper `normalizeLabels` that doesn’t touch external services.
* Validate creator: a dedicated check for creator existence (userService.ValidateUserExists) and debt/* time rules (ValidateMarketResolutionTime), kept separate from monetary checks.
* Ensure funds: isolate the balance/debt requirement in ensureCreateMarketBalance, so funding policy changes don’t touch other steps.
* Build entity: buildMarketEntity constructs the Market with defaults and timestamps, without persistence or validation.
* Persist: a single call to repo.Create that only handles storage errors, no other logic.
* CreateMarket then becomes orchestration: validate shape → normalize labels → verify creator exists → validate resolution window → ensure funds → build entity → persist. Each helper can live in its own file (create_validation.go, create_funding.go, create_entity.go) if you want stricter SRP boundaries.

## Splitting up ensureCreateMarketBalance

Split ensureCreateMarketBalance into narrowly scoped steps so each concern can change independently:

* Compute the charge: a pure helper that determines the fee (e.g., marketCreationFee := s.config.CreateMarketCost) and any future discounts/surcharges. Keep it side‑effect free so pricing policy changes are isolated.
* Validate ability to pay: a check that only answers “may the creator proceed?” (e.g., validateCreatorCanPay(ctx, username, amount) calling ValidateUserBalance or whatever debt policy applies). It should not mutate balances or translate errors; let it return the underlying reason.
* Apply the charge: a separate step that performs the deduction (deductCreationFee(ctx, username, amount)) and handles transaction semantics. This can include idempotency/ledger concerns without touching validation logic.
* Orchestrate in CreateMarket: compute fee → validate → deduct. If you need a single orchestration helper, make it a thin coordinator that just sequences those helpers.

This separation lets pricing/debt policy, eligibility rules, and balance mutation evolve without touching the same function, aligning with SRP.

## Dedicated Settlement/Payment Service

Proposed refactor plan to pull settlement math and payouts into a dedicated settlement/payment service while keeping concerns separated:

### Define narrow contracts

* Add a SettlementCalculator (e.g., CalculatePayoutPositions(ctx, marketID) ([]*PayoutPosition, error)) to separate how winners/amounts are computed from the orchestration. This also helps us make the code more modular, so that administrators can use multiple models.
* Add a PaymentProcessor interface for applying payouts/refunds (e.g., Pay(ctx, username string, amount int64, txType users.TransactionType) error), so transaction semantics live outside markets.
Optionally keep a thin MarketResolverRepo that handles status changes and bet listing without embedding math.

### Extract a settlement service

* Create SettlementService with methods like SettleMarket(ctx, marketID, resolution, resolver) and RefundMarket(ctx, marketID).
* SettleMarket orchestrates: fetch/validate market resolution rights → persist resolution status → branch to payout vs refund → delegate to calculator + payment processor.
* RefundMarket reads bets and calls PaymentProcessor.Pay with TransactionRefund.

### Move math out of markets

* Relocate CalculatePayoutPositions math from repo/service into a calculator implementation (could wrap existing repo method initially, then later move logic from DB to code).
* Keep MarketService free of loops over positions/bets; it should just call the settlement service.

### Relocate payout transaction types

* Centralize win/refund transaction types and amounts inside the settlement/payment layer so changing transaction codes or adding metadata doesn’t affect market orchestration.

### Wire defaults in constructors

* NewSettlementService(repo, calculator, payments) sets defaults and leaves MarketService to inject/use it, reducing runtime mutation.

### Adjust ResolveMarket flow

* In MarketService.ResolveMarket: validate request → call settlement.NormalizeResolution → delegate to SettlementService.SettleMarket.
* Remove refundMarketBets and payoutWinningPositions from service.go; they belong to settlement.

### Testing strategy

* Unit test SettlementService with fakes: one for calculator (controls payouts) and one for payments (captures transactions).
* Integration tests ensure resolution transitions still occur and payouts/refunds are invoked exactly once per winner/bet.

This keeps resolution orchestration in markets, settlement math in its own service, and money movements in a dedicated payment layer, satisfying SRP.

### What happens to the rest of the stuff?

Move the orchestration out of `ResolveMarket` and delegate the branches:

* ResolveMarket in the market service should just validate authorization/state, normalize the resolution string, persist the resolution status, and then hand off to a settlement layer.
* refundMarketBets logic moves into the settlement/payment service as a “refund” path: fetch bets → issue refund transactions via the payment processor. Market service no longer loops bets.
* payoutWinningPositions moves into settlement: the settlement service asks the calculator for payout instructions and calls the payment processor to apply win transactions. Market service doesn’t see positions or transaction types.
* Net: ResolveMarket becomes a thin coordinator, while refund/payout branches live in the settlement/payment service and use the calculator + payment processor contracts.